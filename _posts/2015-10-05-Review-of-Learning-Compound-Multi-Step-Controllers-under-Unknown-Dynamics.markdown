---
layout: post
group: review
title:  "Review of Learning Compound Multi-Step Controllers under Unknown Dynamics"
date:   2015-10-05 10:00:00
categories: jekyll update
mathjax: true
---

**Paper:**
[Learning Compound Multi-Step Controllers under Unknown Dynamics](http://rll.berkeley.edu/reset_controller/reset_controller.pdf)
(W. Han, [S. Levine](http://www.eecs.berkeley.edu/~svlevine/) and [P. Abbeel](http://www.cs.berkeley.edu/~pabbeel/); 2015)

**Code:**
 ?

**Description:** <br />
Vorgestellt wird ein **Reinforcement Learning-Verfahren** zum Trainieren einer **Verkettung von mehreren Steuerungseinheiten** zur Steuerung eines Roboters. Zwei wichtige Voraussetzungen hierfür sind die Berücksichtigung der Zustandsverteilungen, die durch vorhergehende Steuerungseinheiten in der Kette verursacht wurden, und das automatische Trainieren von **Reset-Steuerungseinheiten**, die das System für jede Episode (d.h. für jeden Schritt in der Kette) in seinen Anfangszustand zurücksetzen. Der Anfangszustand jeder Steuerungseinheit wird durch die ihr vorausgehende Steuerungseinheit bestimmt, wodurch sich ein **nicht-stationäres Lernproblem** ergibt. Es wird gezeigt, dass ein von den Autoren [kürzlich entwickeltes Reinforcement Learning-Verfahren](http://papers.nips.cc/paper/5444-learning-neural-network-policies-with-guided-policy-search-under-unknown-dynamics%22), das linear-Gauß'sche Steuerungen mit gelernten, lokalen, linearen Modellen trainiert, derartige Probleme mit nicht-stationären initialen Zustandsverteilungen lösen kann, und dass das gleichzeitige Trainieren von vorwärts gerichteten Steuerungseinheiten zusammen mit entsprechenden Reset-Steuerungseinheiten die Trainingszeit nur minimal erhöht. Außerdem wird das hier vorgestellte Verfahren anhand einer komplexen *"Werkzeug-Verwendungs-Aufgabe"* demonstriert. Die Aufgabe besteht aus sieben verschiedenen Stufen (*"Episoden"*) und setzt die Verwendung eines Spielzeug-Schraubenschlüssels voraus, um eine Schraube einzudrehen. Diese aus mehreren Schritten zusammengesetzte Aufgabe erfordert das Greifen und den Umgang mit komplexen Kontaktdynamiken. Nach dem Training können die Steuerungseinheiten diese Aufgabe schnell und effizient ausführen. Abschließend wird gezeigt, dass das hier vorgestellte Verfahren mit [**"guided Policy Search"**](http://graphics.stanford.edu/projects/gpspaper/index.htm) (*"geführte Strategie-Suche"*) kombiniert werden kann, um nichtlineare neuronale Netzwerk-Steuerungseinheiten für eine *"Greif-Aufgabe" mit beachtlicher Variation in der Zielposition* zu trainieren.

Es wird also ein Verfahren zum Trainieren von linear-Gauß'schen Steuerungen mit lokalen, linearen Modellen verwendet, welches sich insbesondere für nicht-stationäre initiale Zustandsverteilungen eignet. Dies ermöglicht es, das Verfahren zum Trainieren von Reset-Steuerungen und zusammengesetzten Bewegungsabläufen einzusetzen. Durch *"guided Policy Search"* wird dieses Verfahren außerdem so erweitert, dass komplexe, nichtlineare Policies, wie z.B. große neuronale Netze, trainiert werden können. 

Der hier vorgestellte Algorithmus passt zeitlich variierende, lokale, lineare Dynamiken an die Stichproben an, die von der vorhergehende Steuerungseinheit erzeugt wurden, und verwendet diese linearen Dynamiken, um die "Control Policy" (eine zeitlich variierende linear-Gauß'sche Steuerung) mittels einer Variante des [**iterativen LQR-Verfahrens**](https://homes.cs.washington.edu/~todorov/papers/LiICINCO04.pdf) zu optimieren. (LQR = linear-quadratic regulator; Da wir hier eine Gauß'sche Steuerung haben, kann das Wort *"regulator"* hier durch *"Gaussian"* ersetzt werden \\(\rightarrow\\) LQG = linear-quadratic Gaussian.)

Die linear-Gauß'schen Steuerungen, die mit dem hier vorgestellten Ansatz trainiert werden, kodieren eine Verteilung über die Aktionen (Drehmomente), die den Zustand des Roboters in jedem Zeitschritt beeinflussen, was es erlaubt, schnelle, flüssige Roboterbewegungen mit direkter Drehmoment-Steuerung auszuführen. Zeitlich variierende linear-Gauß'sche Steuerungen können zwar eine große Bandbreite von verschiedenem Verhalten repräsentieren, sind jedoch Trajektorien-zentrisch (Bewegungsbahn-zentriert?) und deshalb limitiert in ihrer Möglichkeit, sich auf neue Situationen zu verallgemeinern. Das bedeutet, dass diese linear-Gauß'schen Steuerungen nur mit geringen Variationen klarkommen. Eine Policy zum Aufheben eines Objekts, muss jedoch in der Lage sein, den Roboterarm in einen größeren Bereich von verschiedenen Positionen zu bewegen je nach Lage und Pose des Objekts. Um dieser Limitierung entgegenzuwirken und auch große Variationen geeignet behandeln zu können, werden mehrere linear-Gauß'sche Steuerungen für verschiedene Instanzen der Aufgabe, wie z.B. verschiede Zielobjekt-Positionen, trainiert und in einer einzigen nichtlinearen neuronalen Netzwerk-Policy kombiniert, die mittels *"guided Policy Search"* trainiert wird.  

Eine Verkettung von mehreren Steuerungseinheiten wird inkrementell trainiert. Das bedeutet, zunächst werden die vorwärts gerichteten Steuerungen sequenziell ausgeführt, bis eine von ihnen scheitert. Dann wird die entsprechende Reset-Steuerung ausgeführt und die zuvor gescheiterte, vorwärts gerichtete Steuerung versucht erneut, ihre Aufgabe auszuführen. Wenn alle vorwärts gerichteten Steuerungen erfolgreich waren, wird der Prozess umgedreht und die Reset-Steuerungen werden nacheinander ausgeführt. Erfolg bedeutet hier, dass die Position des Endeffektors seinem Ziel nahe genug ist, wobei "nahe genug" durch einen Distanz-Schwellwert festgelegt wird.

**Experimente:**

* **Experiment zur Reset-Steuerung:** *"Lego-Aufgabe"*, bei der der Roboter einen Lego-Duplo-Stein auf einen anderen Lego-Duplo-Stein, der sich an einer festgelegten Position befindet, stecken soll.

* **Experiment zur verkettung mehrerer Steuerungseinheiten:** *"Werkzeug-Verwendungs-Aufgabe"*, bei der der Roboter einen Spielzeug-Schraubenzieher aufnehmen soll, um damit eine Spielzeug-Schraube einzudrehen. Diese Aufgabe besteht aus 7 Schritten und wird durch eine Sequenz von vorwärts gerichteten Steuerungseinheiten und Reset-Steuerungseinheiten gelöst.

* **Experiment zum Trainieren nichtlinearer neuronaler Netzwerk-Policies:** *"Greif-Aufgabe"*, bei der der Roboter einen Spielzeug-Schraubenzieher greifen soll, dessen Position variiert. Das Greifen wird durch das Ausführen zweier vorwärts gerichteter Steuerungseinheiten durchgeführt: In der ersten Stufe bewegt eine Steuerungseinheit den Arm über den Tisch und in der zweiten Stufe wird eine von fünf verschiedenen Steuerungseinheiten dazu verwendet, den Greifer zum Schraubenzieher zu bewegen. Jede dieser fünf verschiedenen Steuerungseinheiten für die zweite Stufe wurde trainiert den Greifer zu je einer von fünf verschiedenen Position zu bewegen. Der Schraubenzieher wird mittels eines **Kinect-basierten Objekt-Detektors** lokalisiert und diejenige der fünf Steuerungseinheiten, die für die nächstgelegene Position trainiert wurde, wird für die Durchführung der Greifer-Platzierung gewählt. Die fünf Steuerungseinheiten der zweiten Stufe teilen sich eine Reset-Steuerungseinheit, so dass sich zusammen mit der Reset-Steuerungseinheit für die erste Stufe insgesamt 8 Steuerungseinheiten ergeben, die für diese Aufgabe benötigt werden. Die fünf Steuerungseinheiten für das Greifen wurden verwendet, um eine einzige neuronale Netzwerk-Policy zu trainieren. Diese besteht hier aus zwei inneren Schichten mit je 40 Neuronen und verwendet *"Soft Rectifier"* der Form \\(a = \log(z+1)\\) zwischen den ersten beiden Schichten, sowie lineare Verbindungen zur Ausgabeschicht des Netzes.